From d527b774878defc27f317cdde19b5c54fd0d5666 Mon Sep 17 00:00:00 2001
From: Jan Kiszka <jan.kiszka@siemens.com>
Date: Sun, 15 Jan 2012 12:06:12 +0100
Subject: [PATCH] qemu-kvm: Deprecate time drift fix

Remove this divergence from upstream. It is practically unused today as
the default mode is in-kernel irqchip. We keep the command line switch
for now, adding a warning that there is no effect anymore.

The feature can be reintroduced to upstream once we have IRQ paths with
feedback support.

Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
---
 hw/i8254.c      |   28 ++--------------------------
 hw/i8259.c      |   17 -----------------
 qemu-options.hx |    4 ++--
 vl.c            |    4 ++--
 4 files changed, 6 insertions(+), 47 deletions(-)

diff --git a/hw/i8254.c b/hw/i8254.c
index d73a5f2..50ecceb 100644
--- a/hw/i8254.c
+++ b/hw/i8254.c
@@ -347,11 +347,6 @@ static uint32_t pit_ioport_read(void *opaque, uint32_t addr)
     return ret;
 }
 
-/* global counters for time-drift fix */
-int64_t timer_acks=0, timer_interrupts=0, timer_ints_to_push=0;
-
-extern int time_drift_fix;
-
 static void pit_irq_timer_update(PITChannelState *s, int64_t current_time)
 {
     int64_t expire_time;
@@ -362,35 +357,16 @@ static void pit_irq_timer_update(PITChannelState *s, int64_t current_time)
     expire_time = pit_get_next_transition_time(s, current_time);
     irq_level = pit_get_out1(s, current_time);
     qemu_set_irq(s->irq, irq_level);
-    if (time_drift_fix && irq_level==1) {
-        /* FIXME: fine tune timer_max_fix (max fix per tick). 
-         *        Should it be 1 (double time), 2 , 4, 10 ? 
-         *        Currently setting it to 5% of PIT-ticks-per-second (per PIT-tick)
-         */
-        const long pit_ticks_per_sec = (s->count>0) ? (PIT_FREQ/s->count) : 0;
-        const long timer_max_fix = pit_ticks_per_sec/20;
-        const long delta = timer_interrupts - timer_acks;
-        const long max_delta = pit_ticks_per_sec * 60; /* one minute */
-        if ((delta >  max_delta) && (pit_ticks_per_sec > 0)) {
-            printf("time drift is too long, %ld seconds were lost\n", delta/pit_ticks_per_sec);
-            timer_acks = timer_interrupts;
-            timer_ints_to_push = 0;
-        } else if (delta > 0) {
-            timer_ints_to_push = MIN(delta, timer_max_fix);
-        }
-        timer_interrupts++;
-    }
 #ifdef DEBUG_PIT
     printf("irq_level=%d next_delay=%f\n",
            irq_level,
            (double)(expire_time - current_time) / get_ticks_per_sec());
 #endif
     s->next_transition_time = expire_time;
-    if (expire_time != -1) {
+    if (expire_time != -1)
         qemu_mod_timer(s->irq_timer, expire_time);
-    } else {
+    else
         qemu_del_timer(s->irq_timer);
-    }
 }
 
 static void pit_irq_timer(void *opaque)
diff --git a/hw/i8259.c b/hw/i8259.c
index 7e17071..0632ea2 100644
--- a/hw/i8259.c
+++ b/hw/i8259.c
@@ -210,9 +210,6 @@ static void pic_intack(PicState *s, int irq)
     pic_update_irq(s);
 }
 
-extern int time_drift_fix;
-extern int64_t timer_acks, timer_ints_to_push;
-
 int pic_read_irq(PicState *s)
 {
     int irq, irq2, intno;
@@ -232,20 +229,6 @@ int pic_read_irq(PicState *s)
             intno = s->irq_base + irq;
         }
         pic_intack(s, irq);
-
-        /* FIXME: limit to x86, or better, to platforms where irq0 is the
-         * timer interrupts. */
-
-	if (time_drift_fix && s->master && irq == 0) {
-	    timer_acks++;
-	    if (timer_ints_to_push > 0) {
-		timer_ints_to_push--;
-                /* simulate an edge irq0, like the one generated by i8254 */
-                pic_set_irq(s, 0, 0);
-                pic_set_irq(s, 0, 1);
-	    }
-	}
-
     } else {
         /* spurious IRQ on host controller */
         irq = 7;
diff --git a/qemu-options.hx b/qemu-options.hx
index c645f87..d567ba3 100644
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -2633,8 +2633,8 @@ DEF("no-kvm-pit-reinjection", 0, QEMU_OPTION_no_kvm_pit_reinjection,
     "-no-kvm-pit-reinjection\n"
     "                disable KVM kernel mode PIT interrupt reinjection\n",
     QEMU_ARCH_I386)
-DEF("tdf", 0, QEMU_OPTION_tdf,
-    "-tdf            enable guest time drift compensation\n", QEMU_ARCH_ALL)
+HXCOMM -tdf is deprecated and ignored today
+DEF("tdf", 0, QEMU_OPTION_tdf, "", QEMU_ARCH_ALL)
 DEF("kvm-shadow-memory", HAS_ARG, QEMU_OPTION_kvm_shadow_memory,
     "-kvm-shadow-memory MEGABYTES\n"
     "                allocate MEGABYTES for kvm mmu shadowing\n",
diff --git a/vl.c b/vl.c
index c009eb8..1a77de1 100644
--- a/vl.c
+++ b/vl.c
@@ -222,7 +222,6 @@ const char *watchdog;
 QEMUOptionRom option_rom[MAX_OPTION_ROMS];
 int nb_option_roms;
 int semihosting_enabled = 0;
-int time_drift_fix = 0;
 unsigned int kvm_shadow_memory = 0;
 int old_param = 0;
 const char *qemu_name;
@@ -2955,7 +2954,8 @@ int main(int argc, char **argv, char **envp)
                 semihosting_enabled = 1;
                 break;
             case QEMU_OPTION_tdf:
-                time_drift_fix = 1;
+                fprintf(stderr, "Warning: user space PIT time drift fix "
+                                "is no longer supported.\n");
 		break;
             case QEMU_OPTION_kvm_shadow_memory:
                 kvm_shadow_memory = (int64_t)atoi(optarg) * 1024 * 1024 / 4096;
-- 
1.7.6.5

